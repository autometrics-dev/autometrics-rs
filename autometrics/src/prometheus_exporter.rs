#[cfg(feature = "metrics")]
use metrics_exporter_prometheus::{PrometheusBuilder, PrometheusHandle};
use once_cell::sync::Lazy;
#[cfg(feature = "opentelemetry")]
use opentelemetry_prometheus::{exporter, PrometheusExporter};
#[cfg(feature = "opentelemetry")]
use opentelemetry_sdk::export::metrics::aggregation;
#[cfg(feature = "opentelemetry")]
use opentelemetry_sdk::metrics::{controllers, processors, selectors};
#[cfg(any(feature = "opentelemetry", feature = "prometheus"))]
use prometheus::TextEncoder;
use thiserror::Error;

#[derive(Debug, Error)]
pub enum EncodingError {
    #[cfg(any(feature = "prometheus", feature = "opentelemetry"))]
    #[error(transparent)]
    Prometheus(#[from] prometheus::Error),
    #[cfg(feature = "prometheus-client")]
    #[error(transparent)]
    Format(#[from] std::fmt::Error),
}

static GLOBAL_EXPORTER: Lazy<GlobalPrometheus> = Lazy::new(|| GlobalPrometheus {
    #[cfg(feature = "metrics")]
    metrics_exporter: PrometheusBuilder::new()
        .set_buckets(&crate::HISTOGRAM_BUCKETS)
        .expect("Failed to set histogram buckets")
        .install_recorder()
        .expect("Failed to install recorder"),

    #[cfg(feature = "opentelemetry")]
    opentelemetry_exporter: exporter(
        controllers::basic(processors::factory(
            selectors::simple::histogram(crate::HISTOGRAM_BUCKETS),
            aggregation::cumulative_temporality_selector(),
        ))
        .build(),
    )
    .init(),
});

#[derive(Clone)]
#[doc(hidden)]
pub struct GlobalPrometheus {
    #[cfg(feature = "opentelemetry")]
    opentelemetry_exporter: PrometheusExporter,
    #[cfg(feature = "metrics")]
    metrics_exporter: PrometheusHandle,
}

impl GlobalPrometheus {
    fn encode_metrics(&self) -> Result<String, EncodingError> {
        let mut output = String::new();

        #[cfg(feature = "metrics")]
        {
            output.push_str(&self.metrics_exporter.render());
            output.push('\n');
        }

        #[cfg(feature = "opentelemetry")]
        {
            let metric_families = self.opentelemetry_exporter.registry().gather();
            let encoder = TextEncoder::new();
            encoder.encode_utf8(&metric_families, &mut output)?;
            output.push('\n');
        }

        #[cfg(feature = "prometheus")]
        {
            let metric_families = prometheus::default_registry().gather();
            let encoder = TextEncoder::new();
            encoder.encode_utf8(&metric_families, &mut output)?;
            output.push('\n');
        }

        #[cfg(feature = "prometheus-client")]
        {
            prometheus_client::encoding::text::encode(
                &mut output,
                &crate::tracker::prometheus_client::REGISTRY,
            )?;
        }

        #[cfg(feature = "prometheus-client")]
        {
            output.push('\n');
            prometheus_client::encoding::text::encode(
                &mut output,
                &crate::tracker::prometheus_client::REGISTRY,
            )?;
        }

        Ok(output)
    }
}

/// Initialize the global Prometheus metrics collector and exporter.
///
/// You will need a collector/exporter set up in order to use the metrics
/// generated by autometrics. You can either use this one or configure
/// your own following the example from the
/// [`opentelemetry_prometheus`](https://docs.rs/opentelemetry-prometheus/latest/opentelemetry_prometheus/)
/// crate documentation.
///
/// This should be included in your `main.rs`:
/// ```
/// # fn main() {
/// # #[cfg(feature="prometheus-exporter")]
///     let _exporter = autometrics::global_metrics_exporter();
/// # }
/// ```
pub fn global_metrics_exporter() -> GlobalPrometheus {
    GLOBAL_EXPORTER.clone()
}

/// Export the collected metrics to the Prometheus format.
///
/// Create a handler on your API (often, this would be the
/// handler for the route `/metrics`) that returns the result of this function.
///
/// For example, using Axum, you might have a handler:
/// ```rust
/// # use http::StatusCode;
/// // Mounted at the route `/metrics`
/// pub async fn metrics_get() -> (StatusCode, String) {
///   match autometrics::encode_global_metrics() {
///     Ok(metrics) => (StatusCode::OK, metrics),
///     Err(err) => (StatusCode::INTERNAL_SERVER_ERROR, format!("{:?}", err))
///   }
/// }
/// ```
pub fn encode_global_metrics() -> Result<String, EncodingError> {
    GLOBAL_EXPORTER.encode_metrics()
}
