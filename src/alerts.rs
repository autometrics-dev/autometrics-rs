use linkme::distributed_slice;

const WINDOWS: &[&str] = &["5m", "30m", "1h", "2h", "6h", "1d", "3d", "30d"];

pub struct Alert {
    pub function: &'static str,
    pub module: &'static str,
    pub success_rate: Option<&'static str>,
    pub latency_target: Option<&'static str>,
    pub latency_percentile: Option<&'static str>,
}

#[distributed_slice]
pub static METRICS: [Alert] = [..];

pub fn generate_alerts() -> String {
    let recording_rules = METRICS
        .iter()
        .flat_map(|alert| {
            WINDOWS
                .iter()
                .map(|window| error_ratio_recording_rule(alert.function, alert.module, window))
        })
        .collect::<Vec<_>>()
        .join("");
    let objectives = METRICS
        .iter()
        .flat_map(objective_rules)
        .collect::<Vec<_>>()
        .join("");
    let slo_alerts = METRICS
        .iter()
        .map(slo_alert_rules)
        .collect::<Vec<_>>()
        .join("");

    format!(
        "# Prometheus recording and alerting rules generated by autometrics-rs

groups:
- name: autometrics-alert-recordings
  rules:{recording_rules}
- name: autometrics-meta-recordings
  rules:{objectives}
- name: autometrics-slo-alerts
  rules:{slo_alerts}"
    )
}

fn request_rate_query(function: &str, module: &str, window: &str) -> String {
    format!(
        "sum(rate(function_calls_count{{function=\"{function}\",module=\"{module}\"}}[{window}]))"
    )
}

fn error_rate_query(function: &str, module: &str, window: &str) -> String {
    format!(
        "sum(rate(function_calls_count{{function=\"{function}\",module=\"{module}\",result=\"error\"}}[{window}]))"
    )
}

fn success_rate_query(function: &str, module: &str, window: &str) -> String {
    let request_rate = request_rate_query(function, module, window);
    let error_rate = error_rate_query(function, module, window);
    format!("1 - {error_rate} / {request_rate}")
}

fn error_ratio_recording_rule(function: &str, module: &str, window: &str) -> String {
    let expr = success_rate_query(function, module, window);

    format!(
        "
  - record: slo:sli_error:ratio_rate{window}
    expr: {expr}
    labels:
      category: availability
      function: {function}
      module: {module}
      window: {window}"
    )
}

fn objective_rules(alert: &Alert) -> impl IntoIterator<Item = String> {
    let function = alert.function;
    let module = alert.module;
    let labels = format!("{{function=\"{function}\",module=\"{module}\"}}");
    let record_labels = format!(
        "labels:
      function: {function}
      module: {module}"
    );
    [alert.success_rate.map(|success_rate|
        format!(
            "
  - record: slo:objective:ratio
    expr: vector({success_rate})
    {record_labels}
  - record: slo:error_budget:ratio
    expr: vector(1 - {success_rate})
    {record_labels}
  - record: slo:time_period:days
    expr: vector(30)
    {record_labels}
  - record: slo:current_burn_rate:ratio
    expr: slo:sli_error:ratio_rate5m{labels} / on(function, module) group_left slo:error_budget:ratio{labels}
    {record_labels}
  - record: slo:period_burn_rate:ratio
    expr: slo:sli_error:ratio_rate30d{labels} / on(function, module) group_left slo:error_budget:ratio{labels}
    {record_labels}
  - record: slo:period_error_budget_remaining:ratio
    expr: 1 - slo:period_burn_rate:ratio{labels}
    {record_labels}"))]
    .into_iter()
    .filter_map(|x| x)
}

fn slo_alert_rules(alert: &Alert) -> String {
    let function = alert.function;
    let module = alert.module;
    let labels = format!("{{function=\"{function}\",module=\"{module}\"}}",);
    if let Some(success_rate) = alert.success_rate {
        let error_rate = format!("(1 - {})", success_rate);
        format!(
            "
  - alert: HighErrorRate
    expr: |
      (
        max(slo:sli_error:ratio_rate5m{labels} > (14.4 * {error_rate}))
        and
        max(slo:sli_error:ratio_rate1h{labels} > (14.4 * {error_rate}))
      )
      or
      (
        max(slo:sli_error:ratio_rate30m{labels} > (6 * {error_rate}))
        and
        max(slo:sli_error:ratio_rate6h{labels} > (6 * {error_rate}))
      )
    labels:
      category: availability
      severity: pageteam
    annotations:
      summary: High error rate for function '{function}' in module '{module}'
      title: (page) {function} {module} SLO error budget burn rate is too fast.
  - alert: HighErrorRate
    expr: |
      (
        max(slo:sli_error:ratio_rate2h{labels} > (3 * {error_rate}))
        and
        max(slo:sli_error:ratio_rate1d{labels} > (3 * {error_rate}))
      )
      or
      (
        max(slo:sli_error:ratio_rate6h{labels} > (1 * {error_rate}))
        and
        max(slo:sli_error:ratio_rate3d{labels} > (1 * {error_rate}))
      )
    labels:
      category: availability
      severity: ticket
    annotations:
      summary: High error rate for function '{function}' in module '{module}'
      title: (ticket) {function} {module} SLO error budget burn rate is too fast."
        )
    } else {
        String::new()
    }
}

// fn latency_query(function: &str, module: &str, window: &str) -> String {
// let latency = format!(
// "sum by (le, function, module) (rate({bucket_name}{{{label_key}=\"{label_value}\"}}[5m]))"
// );
// format!(
// "histogram_quantile(0.99, {latency}) or
// histogram_quantile(0.95, {latency})"
// )
// }

// fn concurrent_calls_query(gauge_name: &str, label_key: &str, label_value: &str) -> String {
// format!("sum by (function, module) {gauge_name}{{{label_key}=\"{label_value}\"}}")
// }
