use once_cell::sync::Lazy;
use opentelemetry::sdk::export::metrics::aggregation;
use opentelemetry::sdk::metrics::{controllers, processors, selectors};
use opentelemetry_prometheus::PrometheusExporter;
use prometheus::{Error, TextEncoder};

const HISTOGRAM_BUCKETS: [f64; 10] = [
    10.0, 25.0, 50.0, 75.0, 100.0, 150.0, 200.0, 350.0, 500.0, 1000.0,
];

/// Initialize the global Prometheus metrics collector and exporter.
///
/// You will need a collector/exporter set up in order to use the metrics
/// generated by autometrics. You can either use this one or configure
/// your own following the example from the
/// [`opentelemetry_prometheus`](https://docs.rs/opentelemetry-prometheus/latest/opentelemetry_prometheus/)
/// crate documentation.
///
/// This should be included in your `main.rs`:
/// ```rust
/// # main() {
/// let _exporter = global_metrics_exporter();
/// # }
/// ```
pub fn global_metrics_exporter() -> Lazy<PrometheusExporter> {
    Lazy::new(|| initialize_metrics_exporter())
}

/// Prometheus needs a metrics endpoint to scrape metrics from.
///
/// Create a handler on your API (often, this would be the
/// handler for the route `/metrics`) that returns the result of this function.
///
/// For example, using Axum, you might have a handler:
/// ```rust
/// // Mounted at the route `/metrics`
/// pub fn metrics_get() -> (StatusCode, String) {
///   match autometrics::encode_global_metrics() {
///     Ok(metrics) => (StatusCode::OK, metrics),
///     Err(err) => (StatusCode::INTERNAL_SERVER_ERROR, format!("{:?}", err))
///   }
/// }
/// ```
pub fn encode_global_metrics() -> Result<String, Error> {
    let exporter = global_metrics_exporter();
    let metric_families = exporter.registry().gather();
    let encoder = TextEncoder::new();
    encoder.encode_to_string(&metric_families)
}

pub fn initialize_metrics_exporter() -> PrometheusExporter {
    let controller = controllers::basic(
        processors::factory(
            selectors::simple::histogram(HISTOGRAM_BUCKETS),
            aggregation::cumulative_temporality_selector(),
        )
        .with_memory(true),
    )
    .build();

    opentelemetry_prometheus::exporter(controller)
        // Use the prometheus crate's default registry so it still works with custom
        // metrics defined through the prometheus crate
        .with_registry(prometheus::default_registry().clone())
        .init()
}
